debug=0
#####Migration to R of S-Plus VDC application 'PED Maritimes>Research Surveys>01) CDN Ecosystem>Num/Wgts using Spls'
#####Intended to work on Plone site
#####M Fowler Sept 20 2012
#####original gui interface: \MFDSTATSERVER\splus70server\WWWRoot\aoclientwiz\brantonb\gsnumbersandweights.htm
#####original S+ code: \MFDSTATSERVER\splus70server\WWWRoot\aocwiz\mfagelength2\mfnumbersandweights.dmp
html.table <- function(df,main="",center="F",tableSummary="")
{
  cat("<table  class='altrowstable' id='alternatecolor' summary=\"tableSummary\">")
  cat("<caption><em>")
    cat(main)
  cat("</em></caption>\n")
  cat("<tr>")
    #cat("<th>");cat("</th>") # empty row number title
    nvar = length(df)
    for (i in 1:nvar) { 
      cat("<th>",names(df[i]),"</th>")
    }
  cat("</tr>\n")
  nrows = length(df[[1]])
  if (length(nrows)>0) {
   for (row in 1:nrows) {
     cat("<tr onmouseover='this.style.backgroundColor=&quot;#ffff66&quot' onmouseout='this.style.backgroundColor=&quot;&quot;'>")
     for (col in 1:nvar) {
      cat("<td >",df[[col]][row],"</td>")
     }
     cat("</tr>\n")
   }
  }
  cat("</table>")
}



ThisFunction <- function(args)
  {

    #Migrated to R: M Fowler Sep 20, 2012
    #Entry point function generated by web tools, SS 2000

  for (i in 1:length(args)) { 
	  if (length(names(args[i]) > 1)) {
		assign(names(args[i]),args[[i]],envir=.GlobalEnv) 
	  }
  }
 ##!##	# title
	arg1 <- args["Data1"]
# graph layout
	arg2 <- args["Data2"]	
# independant scaling
	arg3 <- args["independentscaling"] 
	bindex <- grep("bind__",names(args)); 
    bindvars <<- as.list(args[unlist(bindex)])
 	df1<-ParseSQL(formData)
	#MMM May 13, 2013 - modified ROracleConn to return dataframe of results and SQL as a list
	#Here we capture each and return the df1 back to its original form ASAP.
	#Changes to ROrcaleConn mfagelength2 and mfnumbersandweights need to be done simultaneously 
	querySent<-df1[[2]]
	df1[[2]]<-NULL
	df1<-as.data.frame(df1)
	
if (df1[1]!="bad"){
	html.table(df1,main=arg1)
####MMM May 15 - removing these routines that save all exportable info initially, 
####settling on single, external export routine	
####zname <- tempFileName(".xls")
####zpath <- paste("E:/Apache/Apache2/tmp/",zname,sep="")
#####zpath <- paste("C:/Program Files (x86)/Apache Group/Apache2/tmp/",zname,sep="")
####zz <- file(zpath, "w")  # open an output file connection
####for (j in 1:length(df1[1:length(df1)])){
####	cat(names(df1[j]),df1[[j]],file=zz,sep="\t",append=TRUE);cat(file=zz,sep="\r\n",append=TRUE)
####}  
####close(zz)
####cat('<BR>Download this table\'s data as a <A href="http://', Sys.getenv("http_host"),'/tmp/',zname,'">tab-delimited data.xls</A><P>',sep="")
##MMM May 13, 2013 The following gathers stuff to send to the export function	
##may want to use this technique for plots as well (generate on command, rather than in advance)
theRefererer<-strsplit(Sys.getenv("http_referer"),"/")
thePage<-gsub(".htm","",theRefererer[[1]][length(theRefererer[[1]])])
runTime<-Sys.time()
fileName<-paste(thePage,format(runTime, "%Y%m%d_%H%I%S"),sep='')
#zpath <-"C:/Program Files (x86)/Apache Group/Apache2/tmp/"
fullPath<-paste(Sys.getenv("TMPDIR"),fileName,".Rda",sep='')
thisData<-list(df1,bindvars,querySent,Sys.getenv("TMPDIR"),runTime)

save(thisData,file=fullPath)
cat(paste("<A href='Export.R?",fileName,"'>Generate downloadable versions of this data</A>", sep=''))

cat('<br><br><input type="checkbox" onclick=toggle("plots");>Show Plots ...</input><br>')
cat("<div id='plots'  style='display:none'>")
#	if (debug==1){cat(unlist(df1))}
#####df1 <- as.data.frame(objs)
    names(df1)=toupper(chartr("_",".",names(df1)))
	#cat(names(df1)[[2.]][4.:dim(df1)[2.]])
    #Perform analysis here. Place any functions you are defining OUTSIDE of this entry point function.
    #Put your S-PLUS code here
    # R Branton 2001/10/10
	# purpose: numbers and weight plots
	# arg1 : title
    # arg2 : to overlay or not to overlay 0/1 t/f
    #Initialize graphics, capture GUI warnings  
    #OpenGraphicsDevice(ao)
	src <- CGIwithR_PNG_Open()
		#src <- CGIwithR_PNG_Close(src)
		#src <- CGIwithR_PNG_Open()
    my.overlay <- substring(arg2, 1., 1.)
    my.axis <- "left"
	#cat(dimnames(df1)[[2.]][4.:dim(df1)[2.]])
    #for(column.name in dimnames(df1)[[2.]][[1]]) {	
	
    for(column.name in dimnames(df1)[[2.]][4.:dim(df1)[2.]]) {
	#MMM, Apr 2013, removed this line which prevents the entire plot from showing up if it contains an NA
      #if(!is.na(sum(as.numeric(df1[, paste(column.name)])))) {
        my.data <- df1[, paste(column.name)]
		#my.data[my.data==0] <- NA
#cat(my.overlay,":",column.name,": ",my.axis,"<hr>")
		if (my.axis == "left" || my.overlay == "f") {
        #if ((my.axis == "left") || (my.overlay == "1") || (my.overlay == "f") || (my.overlay == "F")) {
			src <- CGIwithR_PNG_Open()
			finished <-0
			par(mai = c(1.41, 1.13, 1.13, 1.41) + 0.1)
			plot(df1$YEAR, my.data, type = "l", ylab = paste(column.name), xlab = "YEAR", lwd = 2., cex = 1.5, las = 1.)
			#mtext(side = 3., line = 3., paste(arg1), cex = 1.5, adj = 0.7)
			prev.column.name <- column.name
			my.axis <- "right"
			
			if (my.overlay == "f") {
				src <- CGIwithR_PNG_Close(src)
				finished <-1
			} else {
			
			}
        } else {
			par(new = T, xaxs = "r")
			plot(df1$YEAR, my.data, axes = F, xlab = "", ylab = "", type = "l", lty = 4., lwd = 2., las = 1.)
			axis(side = 4., cex = 1.5)
			mtext(side = 4., line = 3, column.name, cex = 1)
			mtext(side = 1., line = 5., cex = 1, paste(prev.column.name, " _____ ",column.name, " _ _ _"), adj = 0.6)
			par(xaxs = "r")
			my.axis <- "left"
			src <- CGIwithR_PNG_Close(src)
			finished <-1
        } 
		

    }
	if (finished==0){

		}
							cat("</div><br>")
    #Prepare dataframes for output, if any
    #Export graphics
    #CloseGraphicsDevice(ao, height = 5.5, width = 8.25)
    dfOut1 <- df1
    for(i in 1.:3.) {
      dfOut1[, i] <- as.character(floor(dfOut1[, i]))
    }
    #Prepare dataframes for output, if any
    
    #dfOut1 <- #Convert data frame for export
    
    #PrepareOutputDataFrame(dfOut1)
    #dfOut1 <- #Convert data frame for export
    
    #PrepareOutputDataFrame(dfOut1)
    #Assign dataframe to memory for retrieval
    
    #assign("dfOut1", dfOut1, frame = 1.)
    #Return output parameters and dataframes, if any
    
    #Assign object to disk for retrieval by subsequent analytic
    
    #assign("df1", df1, where = 1.)
    #list(c(), "dfOut1")
	}
  }

  handlePost <- function() {
if (debug==1){cat("<h3>in handlePost</h3>")}
  startTime <- Sys.time()
  	cat("<HTML><HEAD><TITLE>")
	cat("Results")
	cat("</TITLE><META HTTP-EQUIV='CACHE-CONTROL' CONTENT='NO-CACHE'>")
	cat("<link rel='stylesheet'' type='text/css'' href='/r/rStyle.css'>")
	cat("<script type='text/javascript' src='/r/scripts.js'></script>")
	cat("</HEAD>")
    cat("<script>")
	cat("window.onload=function(){")
	cat("altRows('alternatecolor');")
	cat("}")
   cat("</script>")
    cat("<BODY>")
 # cat("<p><a href='javascript:history.back();'>Go Back</a></p>")
  SQLTime <<- 0
  library(gplots)
  source(file.path("CGIwithR_VDC.R"))
  #source(file.path("tempFileName.R"))
  source(file.path("CGIwithR_PNG_Open.R"))
  source(file.path("CGIwithR_PNG_Close.R"))
  source(file.path("ROracleConn.R"))
  #source(file.path("ExportAsDataFrame.R"))
  TMPDIR="E:/Apache/Apache2/tmp/"
  #TMPDIR="C:/Program Files (x86)/Apache Group/Apache2/tmp/"
  Sys.setenv(TMPDIR=TMPDIR)
  graphDir <<- TMPDIR
  graphURLroot <<- "/tmp/"

  getFormData()
  if (!exists("formData")) {
	cat("No form data found")
  } else {
if (debug==1){cat("<h3>got formData</h3>")}
    cgiCall <- TRUE
	nparam <- length(formData)
  	newFormData <- list()
  for (i in 1:length(formData)) { 
	newFormData <-c(newFormData, names(formData[i]),formData[[i]])
 }
	nparam <- length(newFormData)
    formSend<-list()
	formSend=c(unlist(newFormData[seq(2,length(newFormData),2)]))
	names(formSend)=c(unlist(newFormData[seq(1,length(newFormData),2)]))
	ThisFunction(formSend)
}
    cat("<p><I>VDC R: ", date(),"Elapsed time ",format(Sys.time()-startTime,digits=3)," seconds, "); 
    cat("max. memory used ",memory.size(max=TRUE)," MB</I></p>")
    #warnings()
cat("</BODY></HTML>")
}

  
  result <- handlePost()